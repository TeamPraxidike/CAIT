import fs from 'fs';
import { randomUUID } from 'node:crypto';
import path from 'path';

/**
 * Adapter interface for the FileSystem Port that deals with file management locally.
 * This is used to abstract the file system operations from the rest of the application.
 * This class is used to interact with the local file system (within the server) and
 * not with a cloud bucket storage.
 */
export class LocalFileSystem {
	/**
	 * Creates an instance of LocalFileSystem.
	 * @param {string} basePath - The base directory path where files will be managed.
	 */
	constructor(basePath) {
		this.basePath = basePath;
	}

	/**
	 * Delete a file from the local file system (the server)
	 * @param {string} pathArg - The path to the file
	 */
	deleteFile(pathArg) {
		fs.unlink(path.join(this.basePath, pathArg), (err) => {
			if (err) throw err;
		});
	}

	/**
	 * Edit a file in the local file system (the server)
	 * @param {string} pathArg - The path to the file
	 * @param {Buffer} file - The binary data of the file
	 * @returns {Promise<string>} - Resolves with the file path
	 */
	async editFile(pathArg, file) {
		fs.writeFileSync(path.join(this.basePath, pathArg), file);
		return pathArg;
	}

	/**
	 * Read a file from the local file system (the server) and returns a buffer with the raw binary data.
	 * This function might be better to avoid, as if you are calling it from a server file you can directly access the file system.
	 * @param {string} pathArg - The path to the file
	 * @returns {Promise<Buffer>} - Resolves with the file data
	 */
	async readFile(pathArg) {
		return new Promise((resolve, reject) => {
			fs.readFile(path.join(this.basePath, pathArg), (err, data) => {
				if (err) {
					reject(err);
				} else {
					resolve(data);
				}
			});
		});
	}

	/**
	 * Save a file to local file system (the server)
	 * File is saved in root/uploadedFiles/{name.file}
	 * The name is a random number generated by a random uuid
	 *
	 * @note The file is saved synchronously, might be more efficient to save it asynchronously but
	 * that makes testing harder. For now this is fine. Also, the directory is created if it does not exist.
	 *
	 * @param {Buffer} file - The binary data of the file
	 * @param {string} name - The name of the file - used to determine the file extension
	 * @returns {Promise<string>} - Resolves with the generated file name
	 */
	async saveFile(file, name) {
		if (!file) {
			throw new Error('No file provided');
		}
		try {
			if (!fs.existsSync(this.basePath)) fs.mkdirSync(this.basePath, { recursive: true });

			const fileExtension = (name.split('.').pop()) || '';
			const pathFileNameGenerated = `${randomUUID()}.${fileExtension}`;

			fs.writeFileSync(
				path.join(this.basePath, pathFileNameGenerated),
				file,
			);
			return pathFileNameGenerated;
		} catch (error) {
			throw error;
		}
	}

	/**
	 * Get the base path where files are stored.
	 * @returns {string} - The base path
	 */
	getBasePath() {
		return this.basePath;
	}
}