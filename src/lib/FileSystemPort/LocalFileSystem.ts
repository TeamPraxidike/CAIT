import fs from 'fs';
import { randomUUID } from 'node:crypto';
import type FileSystem from '$lib/FileSystemPort/FileSystem';
import path from 'path';

/**
 * Adapter interface for the FileSystem Port that deals with file management locally.
 * This is used to abstract the file system operations from the rest of the application.
 * This class is used to interact with the local file system (within the server) and
 * not with a cloud bucket storage.
 */
export class LocalFileSystem implements FileSystem {
	//readonly basePath = 'static\\uploadedFiles\\';
	readonly basePath = path.join('static', 'uploadedFiles');

	/**
	 * Delete a file from the local file system (the server)
	 * @param pathArg the path to the file
	 */
	deleteFile(pathArg: string) {
		fs.unlink(path.join(this.basePath, pathArg), (err) => {
			if (err) throw err;
			console.log(pathArg + ' deleted!');
		});
	}

	/**
	 * Edit a file in the local file system (the server)
	 * @param pathArg the path to the file
	 * @param file the binary data of the file
	 */
	async editFile(pathArg: string, file: Buffer) {
		fs.writeFileSync(path.join(this.basePath, pathArg), file);
		return pathArg;
	}

	/**
	 * Read a file from the local file system (the server) and returns a buffer with the raw binary data.
	 * This function might be better to avoid, as if you are calling it from a server file you can directly access the file system.
	 * @param pathArg the path to the file
	 */
	readFile(pathArg: string): Buffer {
		try {
			console.log('Reading file ' + path.join(this.basePath, pathArg));
			return fs.readFileSync(path.join(this.basePath, pathArg));
		} catch (error) {
			throw error;
		}
	}

	/**
	 * Save a file to local file system (the server)
	 * File is saved in root/uploadedFiles/{name.file}
	 * The name is a random number generated by a random uuid
	 *
	 * @note The file is saved synchronously, might be more efficient to save it asynchronously but
	 * that makes testing harder. For now this is fine. Also, the directory is created if it does not exist.
	 *
	 * @param file the binary data of the file
	 * @param name  the name of the file - used to determine the file extension
	 */
	async saveFile(file: Buffer, name: string): Promise<string> {
		if (!file) {
			throw new Error('No file provided');
		}
		try {
			if (!fs.existsSync(this.basePath)) fs.mkdirSync(this.basePath);

			const pathFileNameGenerated =
				`${randomUUID()}` + `.${(name + '').split('.').pop()}`;

			fs.writeFileSync(
				path.join(this.basePath, pathFileNameGenerated),
				file,
			);
			console.log(name + ' saved as ' + pathFileNameGenerated);
			return pathFileNameGenerated;
		} catch (error) {
			throw error;
		}
	}

	getBasePath() {
		return this.basePath;
	}
}
