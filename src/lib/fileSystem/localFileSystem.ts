import fs from "fs";
import {randomUUID} from "node:crypto";

export class LocalFileSystem {
    readonly basePath = 'static/uploadedFiles/';

    /**
     * Delete a file from the local file system (the server)
     * @param path the path to the file
     */
    deleteFile(path: string) {
        fs.unlink(this.basePath + path, (err) => {
            if (err) throw err;
            console.log(path + ' deleted!');
        });
    }

    /**
     * Edit a file in the local file system (the server)
     * @param path the path to the file
     * @param file the binary data of the file
     */
    async editFile(path: string, file: Blob) {
        this.deleteFile(path);
        await this.saveFile(file, path);
        return path;
    }

    /**
     * Read a file from the local file system (the server) and returns a buffer with the raw binary data.
     * This function might be better to avoid, as if you are calling it from a server file you can directly access the file system.
     * @param path the path to the file
     */
    readFile(path: string) {
        return fs.readFileSync(this.basePath + path);
    }

    /**
     * Save a file to local file system (the server)
     * File is saved in root/uploadedFiles/{name.file}
     * The name is a random number generated by a random uuid
     * @param file the binary data of the file
     * @param name  the name of the file - used to determine the file extension
     */
    async saveFile(file: Blob, name: string): Promise<string> {
        if(!file) {
            throw new Error('No file provided');
        }

        try {
            const fileContent = await file.arrayBuffer();
            const buffer = Buffer.from(fileContent);
            const path = `${randomUUID()}` + `.${(name + "").split('.').pop()}`;

            fs.writeFile(this.basePath + path, buffer, function (err) {
                if (err) throw err;
                console.log('Saved!');
            });
            console.log(name + " saved as " + path);
            return path;
        } catch (error) {
            throw error;
        }
    }

    getBasePath() {
        return this.basePath;
    }
}