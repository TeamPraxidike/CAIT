import fs from "fs";
import {randomUUID} from "node:crypto";
import type FileSystem from "$lib/fileSystem/fileSystem";
import path from 'path'

export class LocalFileSystem implements FileSystem {
    //readonly basePath = 'static\\uploadedFiles\\';
    readonly basePath = path.join("static", "uploadedFiles");

    /**
     * Delete a file from the local file system (the server)
     * @param pathArg the path to the file
     */
    deleteFile(pathArg: string) {
        fs.unlink(path.join(this.basePath, pathArg), (err) => {
            if (err) throw err;
            console.log(pathArg + ' deleted!');
        });
    }

    /**
     * Edit a file in the local file system (the server)
     * @param pathArg the path to the file
     * @param file the binary data of the file
     */
    async editFile(pathArg: string, file: Blob) {
        fs.writeFileSync(path.join(this.basePath, pathArg), Buffer.from(await file.arrayBuffer()));
        return pathArg;
    }

    /**
     * Read a file from the local file system (the server) and returns a buffer with the raw binary data.
     * This function might be better to avoid, as if you are calling it from a server file you can directly access the file system.
     * @param pathArg the path to the file
     */
    readFile(pathArg: string) {
        try{
            console.log("Reading file " + path.join(this.basePath, pathArg));
            return fs.readFileSync(path.join(this.basePath, pathArg));
        } catch (error) {
            throw error;
        }
    }

    /**
     * Save a file to local file system (the server)
     * File is saved in root/uploadedFiles/{name.file}
     * The name is a random number generated by a random uuid
     *
     * Note: The file is saved synchronously, might be more efficient to save it asynchronously but
     * that makes testing harder. For now this is fine.
     *
     * @param file the binary data of the file
     * @param name  the name of the file - used to determine the file extension
     */
    async saveFile(file: Blob, name: string): Promise<string> {
        if(!file) {
            throw new Error('No file provided');
        }
        try {
            const fileContent = await file.arrayBuffer();
            const buffer = Buffer.from(fileContent);
            const pathFileNameGenerated = `${randomUUID()}` + `.${(name + "").split('.').pop()}`;

            fs.writeFileSync(path.join(this.basePath, pathFileNameGenerated), buffer);
            console.log(name + " saved as " + pathFileNameGenerated);
            return pathFileNameGenerated;
        } catch (error) {
            throw error;
        }
    }

    getBasePath() {
        return this.basePath;
    }
}